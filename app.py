import os
import subprocess
import random
import streamlit as st
import cv2 as cv
import numpy as np
import pandas as pd

from myapp.DeepSegmentor.options.test_options import TestOptions

PATH = 'myapp/DeepSegmentor/datasets/DeepCrack/'
PATH_SPLIT = 'split/'
TEST_PATH = 'test_img/'

RESULTS_PATH = ['myapp/DeepSegmentor/results',
                'myapp/DeepSegmentor/results/deepcrack',
                'myapp/DeepSegmentor/results/deepcrack/test_latest',
                'myapp/DeepSegmentor/results/deepcrack/test_latest/images/']

MAX_PIXELS = 500  # width or height

COMMAND_INFERENCE = 'python3 test.py --dataroot myapp/DeepSegmentor/datasets/DeepCrack --name deepcrack --model deepcrack --dataset_mode deepcrack --batch_size 1 --num_classes 1 --norm batch --num_test 10000 --display_sides 1'
COMMAND_PNG2MP4 = 'ffmpeg -framerate 30 -i ' + \
    RESULTS_PATH[-1] + '%1d_fused.png -vcodec libx264 output.mp4'

METHODS = ['Resize', 'Split (+time)']


def make_abs_path():
    """
    Handle folder myapp as library
    """
    os.path.abspath(os.getcwd())
    return True


def create_folders():
    """
    Create default folders is not exist.
    """
    # Where images are being stored
    if not os.path.isdir(PATH+TEST_PATH):
        os.mkdir(PATH+TEST_PATH)

    for tmp_path in RESULTS_PATH:
        # Where results inference appears
        if not os.path.isdir(tmp_path):
            os.mkdir(tmp_path)


def clean_temp():
    """
    Remove all files in specific paths
    """

    paths_to_remove = ['split',
                       'myapp/DeepSegmentor/datasets/DeepCrack',
                       'myapp/DeepSegmentor/datasets/DeepCrack/test_img/',
                       'myapp/DeepSegmentor/results/deepcrack/test_latest/images']

    try:
        for path in paths_to_remove:
            for f in os.listdir(path):
                if not 'README' in f:
                    os.remove(os.path.join(path, f))
    except Exception as e:
        print(e)

    mp4_to_remove = ['temporal.mp4',
                     'output.mp4']

    for f in mp4_to_remove:
        try:
            os.remove(f)
        except Exception as e:
            print(e)


def clean_other_files_from_results(path=RESULTS_PATH[-1]):
    """
    Removing all temporal files generated by DeepCrack
    Like _image _label_viz _side1..5
    """
    for f in os.listdir(path):
        if not 'fused' in f:
            print("Removing..."+path+f)
            os.remove(path+f)

    return True


def reduce_dims(width, height, scale_percent):
    """
    Reduce dimensions until fit in less of max_pixels
    """

    while width > MAX_PIXELS or height > MAX_PIXELS:
        st.text('Reescalando: Weight-{} Height-{}'.format(width, height))

        width = int(width * scale_percent / 100)
        height = int(height * scale_percent / 100)
        dim = (width, height)

    return dim


def resize_one_image(filename_path):
    """
    Resize one image with filepath
    """

    temp_img = cv.imread(filename_path)

    scale_percent = 80  # downscale percent
    width = int(temp_img.shape[1])
    height = int(temp_img.shape[0])

    # Resize image to reduce inference time and max virtual memory needed
    reduced_dim = reduce_dims(width, height, scale_percent)

    resized = cv.resize(temp_img, reduced_dim,
                        interpolation=cv.INTER_AREA)
    return resized, reduced_dim


def resize_all_images_from_path(path):
    """
    Resize all images given a path.
    """

    # Resize all images
    for f in os.listdir(path):
        st.text(str(path+f))
        resized, reduced_dim = resize_one_image(path+f)  # Resized
        cv.imwrite(path+f, resized)  # Saved

    return reduced_dim


def split_one_image_into_small_images(filename_path, filename):
    """
    Split images into small pieces to don't lose
    details in big pictures
    """
    image = cv.imread(filename_path)

    width = int(image.shape[1])
    height = int(image.shape[0])

    divisions_height = 0
    divisions_width = 0
    while(1):
        if (height/(divisions_height+1) > MAX_PIXELS*2):
            divisions_height += 1
        else:
            break

    while(1):
        if (width/(divisions_width+1) > MAX_PIXELS*2):
            divisions_width += 1
        else:
            break

    st.write(f'Dimensiones de la imagen: alto={height}, ancho={width}')
    st.write(f'Divisiones calculadas: alto={divisions_height}, \
        ancho={divisions_width}')

    slice_window_height = int(height/divisions_height)
    slice_window_width = int(width/divisions_width)
    x=0
    y=0
    for r in range(0, height, slice_window_height):
        y=0
        for c in range(0, width, slice_window_width):
            r_c_name = PATH +TEST_PATH+ \
                str(filename.split(".")[0])+f"_{x}_{y}." + \
                str(filename.split(".")[-1].lower())
            print(f'Creating {r_c_name}')
            temp_img = image[r:r+slice_window_height,
                            c:c+slice_window_width, :]

            if int(temp_img.shape[0])>MAX_PIXELS and int(temp_img.shape[1]) >MAX_PIXELS:
                cv.imwrite(r_c_name, temp_img)
            y+=1
        x+=1
    return x,y

def split_all_images_into_small_images(path):
    """
    Crop all frames into small pieces to don't lose
    details in big pictures
    """
    pass


def merge_small_images_to_one_big_image(path,x,y):

    images=[]
    for f in os.listdir(path):
        print(f'Reading {RESULTS_PATH[-1]+f}')
        # img=cv.imread()
        images.append(RESULTS_PATH[-1]+f)

    images.sort()

    t=0
    array=[[0]*(y+1)]*(x+1)
    for m in range(x-1):
        for n in range(y-1):
            print(f'array [{m}],[{n}]')
            array[m][n]=cv.imread(images[t])
            t+=1

    array=np.array(array)

    img_tile = concat_vh(array)

    return img_tile

def concat_vh(list_2d):
    
      # return final image
    return cv.vconcat([cv.hconcat(list_h)  for list_h in list_2d])

def split_video_by_frame(video_path, input_drop_path):
    """
    This script will split video into frames with opencv
    """
    # Author: https://gist.github.com/keithweaver/70df4922fec74ea87405b83840b45d57

    cap = cv.VideoCapture(video_path)
    currentFrame = 0
    while(True):
        try:
            # Capture frame-by-frame
            ret, frame = cap.read()
            # Saves image of the current frame in jpg file
            name = input_drop_path + str(currentFrame) + '.jpg'
            print('Creating...' + name)

            cv.imwrite(name, frame)

            # To stop duplicate images
            currentFrame += 1
        except Exception as e:
            break
            print(e)

    # When everything done, release the capture
    try:
        cap.release()
        cv.destroyAllWindows()
    except Exception as e:
        print(e)

    return True


if __name__ == '__main__':

    make_abs_path()  # Handle folder as library
    clean_temp()  # Clean temporal files on each upload
    create_folders()  # Create paths for inputs and results

    # General description

    st.title("Crack detector")
    st.text("Parte de tesis2, esta red neuronal permite detectar \nfisuras en diferentes materiales que automatizan \nprocesos de las inspecciones.")

    st.text("Red neuronal: DeepCrack - Liu, 2019")
    st.text("Aplicación web: Liz F., Milagros M.")
    st.text("Versión: 0.2.0")

    # Method to process video
    st.subheader("1. Method to process video")
    methods = st.radio(
        "",
        (METHODS[0], METHODS[1]))

    # Upload file
    st.subheader("2. Elige una imagen o video")
    uploaded_file = st.file_uploader("Elige una imagen compatible", type=[
        'png', 'jpg', 'bmp', 'jpeg', 'mp4'])

    if uploaded_file is not None:  # File > 0 bytes

        file_details = {"FileName": uploaded_file.name,
                        "FileType": uploaded_file.type,
                        "FileSize": uploaded_file.size}
        st.write(file_details)

        #######################
        # VIDEO UPLOADED FILE
        #######################
        if file_details['FileType'] == 'video/mp4':

            with open('temporal.mp4', 'wb') as f:
                f.write(uploaded_file.getbuffer())

            split_video_by_frame('temporal.mp4', PATH+TEST_PATH)

            random_filename = random.choice(os.listdir(PATH+TEST_PATH))

            st.image(PATH+TEST_PATH+random_filename,
                     caption='Imagen al azar del video',
                     channels="BGR",
                     use_column_width=True)

            # Applying neural network: DeepCrack - Liu, 2019
            st.subheader('Ejecutando red neuronal DeepCrack... ')

            # Resize all images
            reduced_dim = resize_all_images_from_path(PATH+TEST_PATH)

            # INFERENCE
            result = os.popen(COMMAND_INFERENCE).read()

            # For CPU NN Inference we need to be sure that no gpu is being used by
            # the general script
            st.text(result)
            st.text("GPUS:"+"(if null -> cpu) \n")

            # Clean other files
            clean_other_files_from_results()  # default on result path

            # JPG -> MP4
            result = os.popen(COMMAND_PNG2MP4).read()
            st.text(result)

            # Display video
            st.subheader("Video procesado")
            st.video('output.mp4')

        #######################
        # IMAGE UPLOADED FILE
        #######################
        elif (file_details['FileType'] == 'image/png' or
              file_details['FileType'] == 'image/jpg' or
              file_details['FileType'] == 'image/jpeg' or
              file_details['FileType'] == 'image/bmp'):

            file_bytes = np.asarray(
                bytearray(uploaded_file.read()), dtype=np.uint8)
            image = cv.imdecode(file_bytes, 1)

            if methods == METHODS[0]:
                #######################################
                # IMAGE UPLOADED FILE - RESIZE METHOD
                #######################################

                cv.imwrite(PATH+TEST_PATH+uploaded_file.name, image)

                st.write("This is your uploaded image:")
                st.image(image, caption='La imagen que subiste',
                         channels="BGR", use_column_width=True)

                resized, reduced_dim = resize_one_image(
                    PATH+TEST_PATH+uploaded_file.name)

                # Display rezized image
                st.subheader("Redimensionando imagen...")
                st.image(resized, caption='La imagen escalada para poder ser procesada en la red neuronal sin saturar',
                         channels="BGR", use_column_width=True)
                cv.imwrite(PATH+TEST_PATH+uploaded_file.name, resized)

                # Applying neural network: DeepCrack - Liu, 2019
                st.subheader('Ejecutando red neuronal DeepCrack... ')

                # INFERENCE
                result = os.popen(COMMAND_INFERENCE).read()

                # For CPU NN Inference we need to be sure that no gpu is being used by
                # the general script
                st.text("GPUS:"+result+"(if null -> cpu) \n")

                # Results
                st.subheader('Inferencia terminada: resultados')

                # Get result image and display
                # st.text("Abriendo {}".format(RESULTS_PATH[-1]+uploaded_file.name[:-4]+"_fused.png"))
                result_image = cv.imread(
                    RESULTS_PATH[-1]+uploaded_file.name[:-4]+"_fused.png")
                st.image(result_image,
                         caption='La imagen que subiste',
                         channels="BGR",
                         use_column_width=True)

            elif methods == METHODS[1]:
                #######################################
                # IMAGE UPLOADED FILE - SPLIT METHOD
                #######################################

                cv.imwrite(PATH_SPLIT+uploaded_file.name, image)

                st.write("This is your uploaded image:")
                st.image(image,
                         caption='La imagen que subiste',
                         channels="BGR",
                         use_column_width=True)

                # resized, reduced_dim = resize_one_image(PATH+TEST_PATH+uploaded_file.name)
                x,y=split_one_image_into_small_images(
                    PATH_SPLIT+uploaded_file.name, uploaded_file.name)

                # Display rezized image
                st.subheader(
                    "Imagen dividida en pequeñas images para procesar...")
                # st.image(resized,
                #          caption='La imagen escalada para poder ser procesada en la red neuronal sin saturar',
                #          channels="BGR",
                #          use_column_width=True)
                # cv.imwrite(PATH+TEST_PATH+uploaded_file.name, resized)

                # Applying neural network: DeepCrack - Liu, 2019
                st.subheader('Ejecutando red neuronal DeepCrack... ')

                # INFERENCE
                result = os.popen(COMMAND_INFERENCE).read()

                # For CPU NN Inference we need to be sure that no gpu is being used by
                # the general script
                st.text("GPUS:"+result+"(if null -> cpu) \n")

                # Clean other files
                clean_other_files_from_results() 

                # Merge small images
                image_out=merge_small_images_to_one_big_image(RESULTS_PATH[-1],x,y)

                # Results
                st.subheader('Inferencia terminada: resultados')


                st.text("Imagen de salida")
                cv.imwrite(PATH_SPLIT+"/output_"+uploaded_file.name,image_out)
                st.image(image_out, caption='La imagen que subiste',
                         channels="BGR", use_column_width=True)
